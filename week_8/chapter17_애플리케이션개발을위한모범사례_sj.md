### 1. 모든 것을 하나로 모아보기

![image.png](attachment:1cfc7727-ad24-483e-942c-b51dbd519cfe:image.png)

- **애플리케이션 매니페스트의 구성**
    - **애플리케이션 매니페스트**에는 보통 하나 이상의 **Deployment** 또는 **StatefulSet** 오브젝트가 포함된다.
    - **Pod 템플릿**을 포함하고 있으며, 이 템플릿은 하나 이상의 **컨테이너**를 포함한다. 각 컨테이너에는 **liveness probe**와 **readiness probe**가 포함된다.
        - **Liveness probe**: 컨테이너가 살아 있는지 확인.
        - **Readiness probe**: 서비스가 준비되었는지 확인.

- **서비스 노출**
    - 다른 사람에게 서비스를 제공하는 파드는 하나 이상의 서비스를 통해 외부에 노출된다. 외부에서 클러스터에 접근해야 할 경우, 서비스는 다음과 같은 방법으로 노출될 수 있다:
    - 클러스터 외부로 통신할 수 있어야 하는 경우, 서비스는 로드밸런서, 노드포트 유형 서비스로 구성되거나 인그레스 리소스로 노출된다

- **Secrets과 ConfigMaps**
    - **Secrets**:
        - 파드 템플릿이 컨테이너 이미지를 프라이빗 레지스트리에서 가져오기 위해 사용되는 시크릿.
        - 파드 내에서 실행되는 프로세스에서 사용되는 시크릿.
        - **Secrets**는 보통 애플리케이션 매니페스트에 포함되지 않으며, **운영팀**에 의해 설정되고 **ServiceAccount**에 할당된다. 각 파드는 해당 ServiceAccount를 사용하여 Secrets에 접근한다.
    - **ConfigMaps**:
        - 애플리케이션에는 환경 변수를 초기화하거나 파드에 컨피그맵 볼륨으로 마운트되는 하나 이상의 컨피그맵이 포함돼 있다.
        - 추가적으로 **emptyDir** 또는 **gitRepo** 볼륨을 사용하는 파드도 있다.
        - **Persistent storage**가 필요한 파드는 **persistentVolumeClaim** 볼륨을 사용한다.
        - **PersistentVolumeClaims**는 애플리케이션 매니페스트에 포함되며, **StorageClass**는 시스템 관리자에 의해 사전에 설정된다.

---

- **자동 스케일링 및 리소스 제어**
    - **HorizontalPodAutoscalers**는 애플리케이션 개발자가 매니페스트에 포함시키거나, 운영팀이 나중에 시스템에 추가한다.
    - **LimitRange**와 **ResourceQuota** 객체는 **클러스터 관리자**에 의해 설정되어 각 파드 및 전체 파드의 **컴퓨팅 리소스 사용량**을 제어한다.

- **배포 후 리소스**
    - 애플리케이션이 배포된 후, 다양한 Kubernetes 컨트롤러에 의해 추가 객체가 자동으로 생성된다:
        - **Endpoints** 객체는 **Endpoints controller**에 의해 생성된다.
        - **ReplicaSets**는 **Deployment controller**에 의해 생성된다.
        - 실제 **Pods**는 **ReplicaSet**, **Job**, **CronJob**, **StatefulSet**, 또는 **DaemonSet** 컨트롤러에 의해 생성된다.

- **리소스 라벨과 애너테이션**
    - 리소스들은 **라벨(label)**을 사용하여 **조직화**된다. 이는 파드뿐만 아니라 다른 리소스에도 적용된다.
        - **애너테이션(annotation)**: 리소스에 대한 추가 정보를 제공하거나, 리소스를 관리하는 사람의 연락처 정보, 메타데이터를 제공한다.

### 2. 파드 라이프사이클 이해

- vm과 달리 파드에서 실행 중인 애플리케이션은 언제든지 종료될 수 있다.

**1) 파드 재배치 예상하기**

- 로컬 IP와 호스트 이름 변경 예상하기
    - 파드가 종료되었다가 다시 실행되면 새로운 IP 주소와 새로운 호스트 이름을 갖게 됨.
    - 따라서 애플리케이션이 특정 파드의 IP 주소에 의존하지 않도록 설계해야 함.
    - 호스트 이름을 기반으로 할 때에는 항상 스테이트풀셋을 사용해야 함
- 디스크에 기록된 데이터가 사라지는 경우 예상하기
    - 파드가 종료되고 새로운 파드로 실행 되는 경우 & 파드는 그대로더라도 컨테이너가 재시작하는 경우, 애플리케이션이 디스크에 쓴 파일은 사라질 수 있다.
    - 컨테이너가 재시작되면 새 컨테이너는 완전히 새로운 쓰기 가능한 레이어로 시작하기 때문
    
    ![image.png](attachment:e6509ac8-6e0c-4f4c-8e0e-1826bab0ce2d:image.png)
    
- 컨테이너를 다시 사용하더라도 데이터를 보존하기 위해 볼륨 사용하기
    - 컨테이너가 다시 시작되더라도 데이터가 손실되지 않도록 하기 위해서는 최소한 파드 범위의 볼륨을 사용해야 한다.
    - 하지만 이 방식이 항상 옳은 것은 아님! 데이터가 손상돼 새로 생성된 프로세스가 다시 크래시 되면 → 연속 크래시 루프 발생 (CrashLoopBackOff). 이 경우에는 볼륨을 사용하지 않으면 크래시하지 않을 가능성이 높다.
    
    ![image.png](attachment:2548883a-4df4-430e-aadb-dc8e346c5da8:image.png)
    

**2) 종료된 파드 또는 부분적으로 종료된 파드를 다시 스케줄링하기**

- 파드의 컨테이너가 계속 크래시되면 Kubelet이 계속 파드를 재시작 (재시작 간격 지수로 늘어남)
- 레플리카셋에 포함된 여러 파드 중 하나에서 계속 컨테이너 크래시가 발생하더라도 쿠버네티스는 해당 파드를 삭제하고 교체하지 않음 → 레플리카셋 컨트롤러는 파드가 죽은 상태가 됐는지 상관하지 않음. 신경쓰는 건 오직 파드 수가 의도하는 레플리카 수와 일치하는가 여부임

![image.png](attachment:14ebe686-38ac-491d-aedd-8b456522dfbf:image.png)

**3) 원하는 순서로 파드 재시작**

- 원래 쿠버네티스에는 특정 파드를 먼저 실행하고 준비가 됐을때 나머지 파드를 실행하도록 지시할 방법이 없다.
- 하지만 초기화 컨테이너를 사용해서 전제 조건이 충족될때까지 파드의 주 컨테이너가 시작하지 않도록 할 수는 있다.
    - 파드는 여러 개의 초기화 컨테이너를 가질 수 있고, 초기화 컨테이너가 모두 실행 완료 되면 주 컨테이너가 시작된다. → 초기화 컨테이너를 사용해 주 컨테이너 시작을 지연시킬 수 있다.
- 파드 간 의존성 처리를 위한 모범 사례
    - 초기화 컨테이너(init container)로 의존성이 준비될 때까지 기다리는 방식보다, 애플리케이션이 의존성 문제를 스스로 처리하도록 만드는 것이 더 좋다
        - 애플리케이션이 시작된 후에도 의존하는 서비스가 나중에 다운될 수 있기 때문
    - 애플리케이션이 의존성 서비스 문제를 내부적으로 처리할 수 있게 만들어야 함
        - 레디니스 프로브 활용
            - 애플리케이션이 의존하는 서비스에 접근할 수 없다면, 레디니스 프로브를 통해 자신도 "준비되지 않음" 상태임을 알려야 한다.
            - 이렇게 하면 두 가지 이점이 있음
                - 서비스 엔드포인트에 추가되지 않아 트래픽을 받지 않게 됨
                - 디플로이먼트 컨트롤러가 롤링 업데이트 시 "준비되지 않은" 상태를 감지하여 문제가 있는 버전의 배포를 중단
        
        실생활 비유:
        
        식당에서 일하는 요리사를 생각해보세요.
        
        - **나쁜 방식**: 모든 재료가 준비될 때까지 주방에 들어가지 않는 요리사 (초기화 컨테이너 방식)
        - **좋은 방식**: 주방에 들어가서 일을 시작하고, 특정 재료가 없으면 다른 요리를 하거나 대체 재료를 찾는 요리사 (탄력적인 애플리케이션)
        - **레디니스 프로브**: 중요한 재료가 없어 주문을 받을 수 없을 때 "주문 불가" 표시를 하는 것과 같습니다.
        
        이렇게 애플리케이션이 의존성 문제를 스스로 처리하도록 설계하면 더 안정적이고 탄력적인 시스템을 구축할 수 있습니다.
        

**4) 라이프사이클 훅 추가**

- 컨테이너가 시작되거나 종료될 때 실행할 수 있는 특별한 명령이나 프로세스를 정의하는 메커니즘.
- 컨테이너의 시작과 종료 과정을 세밀하게 제어
- 실행 방식
    - **Exec**: 컨테이너 내에서 특정 명령을 실행합니다.
    - **HTTP**: 컨테이너 내 지정된 엔드포인트로 HTTP 요청을 보냅니다.
    
    ```yaml
    apiVersion: v1
    kind: Pod
    metadata:
      name: lifecycle-demo
    spec:
      containers:
      - name: lifecycle-demo-container
        image: nginx
        lifecycle:
          postStart:
            exec:
              command: ["/bin/sh", "-c", "echo '컨테이너 시작됨' > /usr/share/message"]
          preStop:
            exec:
              command: ["/bin/sh","-c","echo '컨테이너 종료 중' > /usr/share/message && sleep 5"]
    ```
    
- **PostStart (시작 후 훅)**
    - 컨테이너의 주 프로세스가 시작된 직후에 실행된다.
    - 주 프로세스와 병렬로 실행됨. (주 프로세스가 완전 시작될때까지 기다리지 않음)
    - 훅이 완료될 때까지 컨테이너는 ContainerCreating인 채로 Waiting 상태가 유지됨 → 파드는 Pending 상태
    - 훅이 실행되지 않거나 0이 아닌 종료코드 반환 → 주 컨테이너 종료됨
    - 사용 사례
        - 설정 파일 생성/수정
        - 의존성 서비스 연결 확인
        - 애플리케이션 초기화 작업 수행
- **PreStop (시작 전 훅)**
    - 컨테이너가 종료되기 직전에 실행됨.
    - 컨테이너를 종료해야 할 경우, kubelet이 종료 전 훅을 실행한 다음 → 주 프로세스에 SIGTERM을 보냄
    - 사용 사례
        - 진행 중인 작업 완료
        - 연결된 클라이언트에 종료 알림
        - 데이터 정리 및 저장
        - 안전한 종료를 위한 지연 시간 추가

**5) 파드 셧다운 이해하기**

- 파드에서 실행 중인 애플리케이션을 어떻게 완전히 종료시키는가?
- 파드의 종료 흐름 : API 서버로 파드 오브젝트 삭제 요청 → API 서버는 deleteTimestamp 필드 설정 →  Kubelet은 파드를 종료해야 함을 확인하면 각 파드의 컨테이너를 종료함 → 각 컨테이너 종료하는 데 시간이 걸리지만 시간제한이 있음 (종료 유예 기간, 파드별로 구성) → 그 다음 아래 일련의 이벤트가 수행됨
    1. 종료 전 훅 (구성된 경우)을 실행하고 완료될 때까지 기다린다. 
    2. SIGTERM 신호를 컨테이너의 주 프로세스로 보낸다. 
    3. 컨테이너가 완전히 종료될 때까지 or 종료 유예 기간이 끝날 때까지 기다린다
    4. 아직 정상적으로 종료되지 않은 경우 SIGKILL로 프로세스를 강제 종료한다. 

![image.png](attachment:3a70df6e-9552-4e98-acbf-eb83ce11a394:image.png)

- 애플리케이션에서 적절한 셧다운 핸들러 구현
    - 만약 애플리케이션이 분산 데이터 저장소라면. 종료 단계에서 파드는 모든 데이터를 나머지 파드로 마이그레이션해 데이터가 손실되지 않도록 해야한다.
    - 파드는 (SIGTERM 혹은 종료 전 훅으로) 종료 신호를 수신하면 데이터 마이그레이션을 시작해야할까? → 권장하지 않음
        - 컨테이너가 종료되었다는게 파드 전체가 종료되었다는 뜻이 아님
        - 쿠버네티스는 파드 종료 시 제한된 시간(terminationGracePeriodSeconds, 기본 30초)만 허용 → 대규모 데이터 마이그레이션은 이 짧은 시간 내에 완료하기 어려움
    - 더 나은 접근 방식
        - **상시 복제**:
            - 데이터를 항상 여러 파드에 복제하여 어떤 파드가 종료되더라도 데이터가 유지되도록 설계
            - 예: 레플리케이션 팩터를 3 이상으로 설정하여 데이터를 항상 3개 이상의 노드에 복제
        - **프로액티브 리밸런싱**:
            - 파드 종료 전에 주기적으로 또는 클러스터 변화를 감지하여 데이터 재분배
            - 예: 사용률이 낮은 시간대에 리밸런싱 작업 스케줄링
        - **컨트롤러 기반 마이그레이션**:
            - 파드 종료를 감지하는 별도의 컨트롤러를 만들어 안전한 데이터 마이그레이션 오케스트레이션
            - 마이그레이션 완료 후에만 파드가 실제로 종료되도록 관리

### 3. 모든 클라이언트 요청의 적절한 처리 보장

- 파드의 클라이언트 관점에서 파드의 라이프사이클을 살펴보자
- 파드를 스케일 업/스케일 다운할 때 클라이언트가 문제를 겪지 않게 하려면?

**1) 파드가 시작될 때 클라이언트 연결 끊기 방지**

- 파드가 시작되면 레이블 셀렉터가 파드의 레이블과 일치하는 모든 서비스의 앤드포인트에 추가함
- 파드 스펙에 레디니스 프로프 지정하여 파드가 준비가 되었을때 서비스의 앤드 포인트에 추가되도록 함

**2) 파드 셧다운 동안 연결 끊어짐 방지**

- 파드는 종료 신호를 보낸 후에도 클라이언트의 요청을 받을 수 있다.
    - 파드에서 애플리케이션 종료하는데 걸리는 시간이 Kube-proxy가 iptables 수정하는데 걸리는 시간보다 약간 더 짧다.
    - 애플리케이션이 서버 소켓을 닫고 연결 수락을 즉시 중지하면 클라이언트가 “Connection Refused” 오류를 수신하게 됨

![image.png](attachment:6b5d9c04-7dbe-4a28-8c8f-84fd77641632:image.png)

![image.png](attachment:ef031d99-f735-4d42-82d8-a0d57b51a1d8:image.png)

- 문제 해결
    - 모든 kube-proxy가 iptables 규칙을 업데이트할 때까지 충분한 시간을 기다리기 (약 5~10초 정도)

![image.png](attachment:19c0cec8-3a3d-418e-a948-db25693467f8:image.png)
