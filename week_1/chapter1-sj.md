1. p. 49

<img width="427" alt="image" src="https://github.com/user-attachments/assets/e734ff1a-0cf5-401b-8d38-d09ffb8698b4" />


호스트에 가상머신 세 개를 실행하면 세 개의 완전히 분리된 운영체제가 실행되고 동일한 베어메탈 하드웨어를 공유하게 된다. 이런 가상머신 아래에는 물리적 하드웨어 리소스를 각 가상 머신 내부의 운영체제에서 사용할 수 있는 더 작은 리소스로 나누는 호스트 OS와 하이퍼바이저가 있다. 해당 가상머신 내에서 실행되는 애플리케이션이 가상머신의 게스트 OS 커널에 대한 시스템 콜을 수행하면, 커널은 하이퍼바이저로 호스트의 물리적 CPU에서 x86 명령을 수행한다.

---

1) 위 과정을 좀 더 상세하게 설명하면?

<aside>
💡

- 가상머신 안에서 애플리케이션이 실행 중입니다
- 이 애플리케이션이 뭔가 작업을 하려면 (예: 파일 읽기, 네트워크 통신 등) 시스템 콜을 합니다
- 이 시스템 콜은 가상머신의 게스트 OS 커널로 전달됩니다
- 게스트 OS 커널은 실제로는 가상화된 환경에서 동작하고 있기 때문에, 직접 물리적 CPU에 접근할 수 없습니다
- 따라서 커널은 하이퍼바이저에게 "이 명령을 실행해줘"라고 요청합니다
- 하이퍼바이저는 이 요청을 받아서 실제 물리적 CPU에서 해당 x86 명령을 실행합니다
</aside>

2) x86 명령이란?

<aside>
💡

x86 명령은 Intel이나 AMD같은 CPU 제조사들이 만든 CPU가 이해할 수 있는 기계어 명령어입니다. 우리가 흔히 사용하는 대부분의 PC나 서버는 x86 아키텍처 기반의 CPU를 사용합니다.

예를 들어보겠습니다:

1. 우리가 Python으로 `print("Hello")`라는 코드를 작성하면
2. 이 코드는 결국 CPU가 이해할 수 있는 저수준의 기계어 명령으로 변환되어야 합니다
3. 이때 변환된 기계어가 바로 x86 명령입니다
4. 예를 들어 "메모리의 이 위치에서 데이터를 읽어라", "두 숫자를 더해라", "결과를 저장해라" 같은 아주 기초적인 명령들입니다

그래서 "물리적 CPU에서 x86 명령을 실행한다"는 것은:

- 가상머신에서 실행된 프로그램의 요청이
- 결국에는 실제 하드웨어 CPU가 이해할 수 있는 기초적인 명령어로 변환되어
- CPU에서 직접 실행된다는 의미입니다
</aside>

3) 만약 베어메탈 머신의 CPU가 x86명령을 사용하지 않는다면?

<aside>
💡

ARM이나 RISC-V와 같은 다른 CPU 아키텍처를 사용하는 경우를 설명해드리겠습니다.

예를 들어 애플의 M1/M2 맥북이나 대부분의 스마트폰은 ARM 아키텍처 CPU를 사용합니다. 이런 경우:

1. 바이너리 호환성 문제가 발생합니다
- x86용으로 컴파일된 프로그램은 ARM CPU에서 직접 실행할 수 없습니다
- 반대로 ARM용으로 컴파일된 프로그램은 x86 CPU에서 직접 실행할 수 없습니다
1. 이 문제를 해결하기 위한 방법들:
- 에뮬레이션:
    - x86 명령어를 ARM 명령어로 실시간 변환해서 실행
    - 예: 애플 M1 맥북의 Rosetta 2는 x86 프로그램을 ARM에서 실행할 수 있게 해줍니다
    - 단점: 성능 저하가 발생할 수 있습니다
- 크로스 컴파일:
    - 프로그램을 다른 아키텍처용으로 다시 컴파일
    - 예: 리눅스 프로그램을 ARM용으로 다시 컴파일
    - 장점: 네이티브 성능을 얻을 수 있습니다
- 멀티 아키텍처 바이너리:
    - 하나의 프로그램에 여러 아키텍처를 위한 코드를 포함
    - 예: macOS의 Universal Binary
    - 단점: 파일 크기가 커집니다

따라서 서버나 클라우드 환경에서 가상화를 사용할 때는, 호스트 CPU 아키텍처와 호환되는 게스트 OS와 애플리케이션을 사용하는 것이 가장 좋은 성능을 얻을 수 있습니다.

</aside>

4) 베어메탈 머신이 ARM CPU를 사용할때, 하이퍼바이저는 그러면 VM으로부터 받은 시스템콜 명령을 ARM CPU에 맞게 변환해주는건가?

<aside>
💡

네, 정확히 이해하셨습니다. 하이퍼바이저의 중요한 역할 중 하나가 바로 그것입니다.

하이퍼바이저는 두 가지 방식으로 이를 처리할 수 있습니다:

1. Type 1 하이퍼바이저(네이티브/베어메탈 하이퍼바이저)의 경우:
- VM이 ARM CPU용으로 컴파일된 게스트 OS를 실행 중이라면:
    - 직접 ARM 명령어를 물리적 CPU로 전달
    - 성능이 가장 좋음
- VM이 x86용 게스트 OS를 실행 중이라면:
    - x86 명령어를 ARM 명령어로 변환해야 함
    - 이 과정에서 성능 저하 발생
1. Type 2 하이퍼바이저(호스트 OS 위에서 실행)의 경우:
- 호스트 OS → 하이퍼바이저 → 게스트 OS 순으로 명령어 변환
- 추가적인 오버헤드 발생

실제 운영 환경에서는 보통:

- ARM 서버라면 ARM용 게스트 OS를 사용
- x86 서버라면 x86용 게스트 OS를 사용

이렇게 호스트 CPU와 동일한 아키텍처의 게스트 OS를 사용하는 것이 성능상 가장 유리합니다.

</aside>
