## 1. p. 49

<img width="427" alt="image" src="https://github.com/user-attachments/assets/e734ff1a-0cf5-401b-8d38-d09ffb8698b4" />


호스트에 가상머신 세 개를 실행하면 세 개의 완전히 분리된 운영체제가 실행되고 동일한 베어메탈 하드웨어를 공유하게 된다. 이런 가상머신 아래에는 물리적 하드웨어 리소스를 각 가상 머신 내부의 운영체제에서 사용할 수 있는 더 작은 리소스로 나누는 호스트 OS와 하이퍼바이저가 있다. 해당 가상머신 내에서 실행되는 애플리케이션이 가상머신의 게스트 OS 커널에 대한 시스템 콜을 수행하면, 커널은 하이퍼바이저로 호스트의 물리적 CPU에서 x86 명령을 수행한다.

---

### 1) 위 과정을 좀 더 상세하게 설명하면?

<aside>
💡

- 가상머신 안에서 애플리케이션이 실행 중입니다
- 이 애플리케이션이 뭔가 작업을 하려면 (예: 파일 읽기, 네트워크 통신 등) 시스템 콜을 합니다
- 이 시스템 콜은 가상머신의 게스트 OS 커널로 전달됩니다
- 게스트 OS 커널은 실제로는 가상화된 환경에서 동작하고 있기 때문에, 직접 물리적 CPU에 접근할 수 없습니다
- 따라서 커널은 하이퍼바이저에게 "이 명령을 실행해줘"라고 요청합니다
- 하이퍼바이저는 이 요청을 받아서 실제 물리적 CPU에서 해당 x86 명령을 실행합니다
</aside>

### 2) 만약 베어메탈 머신 CPU가 x86이 아니라 ARM일 때, 하이퍼바이저는 VM으로부터 받은 시스템콜 명령을 ARM CPU에 맞게 변환해주는건가?

<aside>
💡

네, 정확히 이해하셨습니다. 하이퍼바이저의 중요한 역할 중 하나가 바로 그것입니다.

하이퍼바이저는 두 가지 방식으로 이를 처리할 수 있습니다:

1. Type 1 하이퍼바이저(네이티브/베어메탈 하이퍼바이저)의 경우:
- VM이 ARM CPU용으로 컴파일된 게스트 OS를 실행 중이라면:
    - 직접 ARM 명령어를 물리적 CPU로 전달
    - 성능이 가장 좋음
- VM이 x86용 게스트 OS를 실행 중이라면:
    - x86 명령어를 ARM 명령어로 변환해야 함
    - 이 과정에서 성능 저하 발생
1. Type 2 하이퍼바이저(호스트 OS 위에서 실행)의 경우:
- 호스트 OS → 하이퍼바이저 → 게스트 OS 순으로 명령어 변환
- 추가적인 오버헤드 발생

실제 운영 환경에서는 보통:

- ARM 서버라면 ARM용 게스트 OS를 사용
- x86 서버라면 x86용 게스트 OS를 사용

이렇게 호스트 CPU와 동일한 아키텍처의 게스트 OS를 사용하는 것이 성능상 가장 유리합니다.

</aside>
